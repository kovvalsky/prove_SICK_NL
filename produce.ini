######################## Functions #####################
[]
prelude =
    import re

    def part_to_prolog_arg(part):
        if part == 'all':
            return "[]"
        if part.isdigit():
            return part
        if part in 'trial train test'.split():
            "['{}']".format(part)
        return "['{}']".format(part)

    def part_to_sick_filename(part):
        d = {'trial': 'SICK_trial',
             'train': 'SICK_train',
             'test':  'SICK_test_annotated'
            }
        return d[part]

    #########################################
    # abduction-specific

    def flag2par(flag):
        '''Interpret acronyms of parameters.
           cN - core number, rN - rule application number,
           pMN - patterns with M terms and N terms.
        '''
        # lookup table
        mapping = {'al': 'aall',
                   'ch': 'constchk',
                   'w3': 'wn_ant, wn_sim, wn_der',
                   '-k': 'no_kb',
                   '-w': 'no_wn',
                   # rN
                   # induction parameters
                   'ab': 'align-both',
                   'an': 'align-no_align',
                   'aa': 'align-align',
                   'ch': 'constchk',
                   'cKB': 'constKB',
                   'cT': 'compTerms'
                   # pNM
                  }
        if flag in mapping:
            return mapping[flag]
        # cores or rule limit
        m = re.match('[rcpv](\d+)$', flag)
        if m:
            n = int(m.group(1))
            if flag[0] == 'r':
                return "ral({})".format(n)
            # used for injecting version for file,
            # it has no affect for proving
            elif flag[0] == 'v':
                return "v{}".format(n)
            elif flag[0] == 'c':
                if n == 1:
                    return 'true'
                return "parallel({})".format(n if n else '_')
            else: # induction parameter
                return "patterns-({})".format(expand_patterns(str(n)))
        raise ValueError('Unknown flag: {}'.format(flag))

    def flags2pars(flags):
        return ', '.join([ flag2par(f) for f in flags.split(',') ])

    def expand_patterns(pat):
        mappings = {'1': '_',
                    '2': '_@_',
                    '3': '(_@_)@_, _@(_@_)',
                    '4': '_@(_@(_@_)), _@((_@_)@_), (_@_)@(_@_), ((_@_)@_)@_, (_@(_@_))@_'
                    }
        patterns = ','.join([ mappings[p] for p in pat ])
        return "[{}]".format(patterns)

    def TDE2prologList(p):
        d = {'T': 'train',
             'D': 'trial',
             'E': 'test'
            }
        if p in d:
            return "[{}]".format(d[p])
        else:
            return "[{}]".format(','.join([ d[c] for c in p ]))

#########################################################
# Annotations and Annotated simply-typed Terms
#########################################################

# json files needs to be produced separately, not as part of other rules,
# because it takes time to create them and this avoid their accidental creation
[SICK_NL/anno/spacy_%{size}.json]
cond = %{ size in ('sm', 'md', 'lg') }
dep.raw = SICK_NL/raw.spl
dep.py = python/spacy_lex_anno.py
recipe =
    python3 %{py} -s %{size} %{raw} %{target}

[SICK_NL/anno/alpino.json]
dep.alpino_xml_dir = SICK_NL/parses/alpino_xml
dep.py = python/alpino_anno.py
recipe =
    python3 %{py} %{alpino_xml_dir} %{target}

# old rule. now LangPro puts trees and lex anno on the fly
#[SICK_NL/anno_terms/%{parser}.%{anno}.pl]
#dep.anno = SICK_NL/anno/%{anno}.json
#dep.parser = SICK_NL/parses/%{parser}.pl
#dep.sen = SICK_NL/sen.pl
#dep.prolog = prolog/tlg_to_tt.pl
#recipe =
#    swipl -g "write_anno_tts('%{target}', '%{anno}'), halt" -f %{prolog} %{parser} %{sen}

[SICK_NL/parses/%{parser}.pl]
cond = %{ parser in ('alpino_aethel') }
dep.py = python/alpino_terms.py
dep.xml = SICK_NL/parses/alpino_xml
recipe = 
    # needs python 3.10 due to aethel convertor
    python3.10 %{py} %{xml} > %{target}


#########################################################
# LaTex and PDF
#########################################################
[SICK_NL/latex/%{parser}.%{anno}.%{part}.tex]
cond = %{ (part in 'yes no unknown trial train test'.split()) or part.isdigit() }
anno = SICK_NL/anno/%{anno}.json
dep.parser = SICK_NL/parses/%{parser}.pl
dep.sen = SICK_NL/sen.pl
dep.main = prolog/main.pl
filter = %{ part_to_prolog_arg(part) }
predicate = %{ 'tlg_pid_to_latex' if part.isdigit() else 'tlg_ids_to_latex' }
recipe =
    swipl -g "%{predicate}('%{anno}', %{filter}, '%{target}'), halt" -f %{main}  %{parser} %{sen}

[SICK_NL/latex/%{filename}.pdf]
dep.tex = SICK_NL/latex/%{filename}.tex
# lualatex is for large files whiel pdflatex is better for files with non-asci symbols e.g.SICKNL-1964
latex = %{ 'pdflatex' if filename[-1].isdigit() else 'hash_extra=5000000 max_strings=5000000 lualatex' }
recipe =
    %{latex} --output-directory=SICK_NL/latex/ %{tex} > ${target}.log
    rm SICK_NL/latex/%{filename}.{log,aux,tex}

#########################################################
# Stats
#########################################################
#stats.train_trial.alpino.spacy_lg.tree_fix
[stats.%{part_part}.%{parser}.%{anno}.tree_fix]
type = task
parts = %{ ','.join(part_part.split('_')) }
py = python/fixing_rules_per_sen.py
anno_json = SICK_NL/anno/%{anno}.json
recipe =
    swipl -g "parList([parts([%{parts}]), anno_json('%{anno_json}'), 'fix']), test_tlg_to_llf, halt" -f prolog/main.pl  SICK_NL/parses/%{parser}.pl SICK_NL/sen.pl | python3 %{py} SICK_NL/sen.pl



#########################################################
# Running Theorem Proving with different parse trees
#########################################################
[Results/%{part}/%{parser}.%{anno}.ans]
cond = %{ part in 'trial train test'.split() and parser in 'alpino npn npn_robbert'.split() and anno in ('spacy_lg','alpino') }
dep.main = prolog/main.pl
dep.sen = SICK_NL/sen.pl
dep.parser_pl = SICK_NL/parses/%{parser}.pl
anno_json = SICK_NL/anno/%{anno}.json
dep.wn = WNProlog/wn.pl
log = Results/%{part}/%{parser}.%{anno}.log
sick_part = %{ "parts(['{}'])".format(part) }
recipe =
    mkdir -p Results/%{part}/
    ( time swipl -g "parList([%{sick_part}, lang(nl), parallel(_), aall, wn_ant, wn_sim, wn_der, constchck, allInt, anno_json('%{anno_json}'), waif('%{target}')]), entail_all, halt" -f %{main}  %{parser_pl} %{sen} %{wn} ) > %{log} 2>&1

# Results/trial/ccg.ans
[Results/%{part}/%{parser}.ans]
cond = %{ part in 'trial train test'.split() and parser in 'ccg eccg'.split()}
dep.main = LangPro/prolog/main.pl
dep.sen = LangPro/ccg_sen_d/%{ part_to_sick_filename(part) }_sen.pl
dep.parser_pl = LangPro/ccg_sen_d/%{ part_to_sick_filename(part) }_%{parser}.pl
dep.wn = LangPro/prolog/knowledge/wn.pl
log = Results/%{part}/%{parser}.log
recipe =
    mkdir -p Results/%{part}/
    swipl -g "parList([parallel(_), aall, wn_ant, wn_sim, wn_der, constchck, allInt, waif('%{target}')]), entail_all, halt" -f %{main}  %{parser_pl} %{sen} %{wn} > %{log} 2>&1

[Results/%{part}/alpino-npn.%{anno}.ans]
cond = %{ part in ('trial','train','test') and anno in ('spacy_lg','alpino')}
dep.alpino = Results/%{part}/alpino.%{anno}.ans
dep.npn = Results/%{part}/npn.%{anno}.ans
dep.py = LangPro/python/evaluate.py
dep.gold = SICK_NL/sen.pl
recipe =
    mkdir -p Results/%{part}/
    python3 %{py} --sys %{alpino} %{npn} --gld %{gold} --hybrid --write-hybrid %{target}

[Results/%{part}/%{parser}.alpino-spacy_lg.ans]
cond = %{ part in ('trial','train','test') and parser in ('npn','alpino','npn_robbert')}
dep.alpino = Results/%{part}/%{parser}.alpino.ans
dep.spacy = Results/%{part}/%{parser}.spacy_lg.ans
dep.py = LangPro/python/evaluate.py
dep.gold = SICK_NL/sen.pl
recipe =
    mkdir -p Results/%{part}/
    python3 %{py} --sys %{alpino} %{spacy} --gld %{gold} --hybrid --write-hybrid %{target}

#########################################################
# Evaluation and Combination of System Predictions
# No file making involved, only evaluation
#########################################################
[%{part}.%{parser}.%{anno}.score]
type = task
cond = %{ part in 'trial train test'.split() }
dep.ans = Results/%{part}/%{parser}.%{anno}.ans
recipe =
    python3 LangPro/python/evaluate.py --sys %{ans} --gld SICK_NL/sen.pl

# trial.ccg.score
[%{part}.%{parser}.score]
type = task
cond = %{ part in 'trial train test'.split() and parser == 'ccg'}
ans_file = %{ parser if parser == 'ccg' else '{}.alpino-spacy_lg'.format(parser) }
deps = Results/%{part}/%{ans_file}.ans.evaluate

[%{pred_file}.evaluate]
type = task
recipe =
    python3 LangPro/python/evaluate.py --sys %{pred_file} --gld SICK_NL/sen.pl

# seperate files with double underscore
[%{pred__files}.hybrid]
type = task
prediction_files = %{ pred__files.replace('__', ' ') }
dep.py = LangPro/python/evaluate.py
dep.gold = SICK_NL/sen.pl
recipe =
    python3 %{py} --sys %{prediction_files} --gld %{gold} --hybrid

#########################################################
# Problem-wise Comparison of Predictions
#########################################################

# comparison to gold labels
# trial.npn.spacy_lg.N-EC.comp
# trial.alpino-npn.spacy_lg.N-EC.comp
[%{part}.%{parser}.%{anno}.%{pred_labs}-%{gold_labs}.comp]
type = task
cond = %{ part in 'trial train test'.split() and parser in 'npn alpino alpino-npn'.split() }
dep.ans = Results/%{part}/%{parser}.%{anno}.ans
dep.py = python/xlang_compare.py
dep.src_sen = LangPro/ccg_sen_d/SICK_sen.pl
dep.trg_sen = SICK_NL/sen.pl
recipe =
    python3 %{py} --sys %{ans} --src %{src_sen} --trg %{trg_sen} -m %{pred_labs} %{gold_labs} -md

# trial.alpino-npn-vs-ccg.spacy_lg.N-EC.comp
[%{part}.%{parser}-vs-%{ref}.%{anno}.%{pred_labs}-%{gold_labs}.comp]
type = task
cond = %{ part in 'trial train test'.split() and parser in 'npn alpino alpino-npn'.split() }
dep.ans = Results/%{part}/%{parser}.%{anno}.ans
dep.reference = Results/%{part}/%{ ref if 'ccg' in ref else '{}.{}'.format(ref,anno) }.ans
dep.py = python/xlang_compare.py
dep.src_sen = LangPro/ccg_sen_d/SICK_sen.pl
dep.trg_sen = SICK_NL/sen.pl
recipe =
    python3 %{py} --sys %{ans} --ref %{reference} --src %{src_sen} --trg %{trg_sen} -m %{pred_labs} %{gold_labs} -md


#########################################################
# N-fold Cross Validation
#########################################################

# Results/CV-3/TD/alpino.spacy_lg/r50,c0_ab,ch,cKB,cT,p123.log
[%{results}/CV-%{n}/%{part}/%{parser}.%{anno}/%{proving_flags}_%{abduction_flags}.log]
cond = %{ parser in ('npn', 'alpino') }
# parse flags acronyms
ppars = %{ flags2pars(proving_flags) }
apars = %{ flags2pars(abduction_flags) }
anno_json = SICK_NL/anno/%{anno}.json
dep.sen = SICK_NL/sen.pl
dep.trees = SICK_NL/parses/%{parser}.pl
dep.wn = WNProlog/wn.pl
parts = %{ TDE2prologList(part) }
recipe =
    mkdir -p %{results}/CV-%{n}/%{part}/%{parser}.%{anno}/
    ( time swipl -g "parList([lang(nl), anno_json('%{anno_json}'), complete_tree, allInt, aall, wn_ant, wn_sim, wn_der, constchck, %{ppars}]), load_ccg_sen_probs(%{parts}, _, _), cv_induce_knowledge(_PrIDs, _Answers, [fold-%{n}, %{apars}])" -t halt -f prolog/main.pl %{sen} %{trees} %{wn} ) > %{target} 2>&1

#########################################################
# Abduction & Evaluation
#########################################################

# Results/abd_eva/TD_E/alpino.spacy_lg/r50,c0_ab,ch,cKB,cT,p123.log
[%{results}/abd_eva/%{abd}_%{eva}/%{parser}.%{anno}/%{proving_flags}_%{abduction_flags}.log]
cond = %{ parser in ('npn', 'alpino', 'npn_robbert') and anno in ('alpino', 'spacy_lg') }
# parse flags acronyms
ppars = %{ flags2pars(proving_flags) }
apars = %{ flags2pars(abduction_flags) }
anno_json = SICK_NL/anno/%{anno}.json
dep.sen = SICK_NL/sen.pl
dep.trees = SICK_NL/parses/%{parser}.pl
dep.wn = WNProlog/wn.pl
ans = %{ target[:-4] }.ans
abd_parts = %{ TDE2prologList(abd) if abd else '_' }
eva_parts = %{ TDE2prologList(eva) if eva else '_' }
recipe =
    mkdir -p %{results}/abd_eva/%{abd}_%{eva}/%{parser}.%{anno}/
    ( time swipl -g "parList([lang(nl), anno_json('%{anno_json}'), waif('%{ans}'), complete_tree, allInt, aall, wn_ant, wn_sim, wn_der, constchck, %{ppars}]), train_dev_eval_sick_parts((%{abd_parts},[]), _DEV, (%{eva_parts},[]), [%{apars}])" -t halt -f prolog/main.pl %{sen} %{trees} %{wn} ) > %{target} 2>&1


#########################################################
# Batch of experiments
########################################################
[%{paper_results}/final_results.c%{c}.r%{r}]
type = task
log = r%{r},c%{c}_ab,ch,cKB,cT,p123.log
abd_eva_path = %{paper_results}/abd_eva/TD_E
dep.abd_alp_alp = %{abd_eva_path}/alpino.alpino/%{log}
dep.abd_alp_scy = %{abd_eva_path}/alpino.spacy_lg/%{log}
dep.abd_npn_alp = %{abd_eva_path}/npn.alpino/%{log}
dep.abd_npn_scy = %{abd_eva_path}/npn.spacy_lg/%{log}
# cv_path = %{paper_results}/CV-3/TD
# dep.cv_alp_alp = %{cv_path}/alpino.alpino/%{log}
# dep.cv_alp_scy = %{cv_path}/alpino.spacy_lg/%{log}
# dep.cv_npn_alp = %{cv_path}/npn.alpino/%{log}
# dep.cv_npn_scy = %{cv_path}/npn.spacy_lg/%{log}
